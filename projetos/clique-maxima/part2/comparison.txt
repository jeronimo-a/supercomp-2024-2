A única mudança realizada no progama de encontrar a clique máxima a partir da heurística gulosa de forma sequencial foi a paralelização em quatro pontos específicos.

O primeiro ponto foi no laço for de inicialização do vetor de candidatos inicial, na função findMaximumClique. O loop simplesmente preenche um vetor com números ordenados que vão de 0 até a quantidade total de nodes menos 1, portanto, as mudanças que ocorrem no vetor são completamente compartimentalizadas, bastando assim dividir as iterações do loop entre a maior quantidade de threads possível, de forma indiscriminada.

O segundo ponto de paralelização foi na inicialização da matriz de grau por nó, dentro da função sortNodesByDegree. A paralelização, apesar de desta vez o vetor ser bidimensional, foi feita de forma similar à do ponto anterior. Trata-se de um laço duplo aninhado, no qual apenas uma linha da matriz é manipulada por iteração, facilitando o processo de paralelização. Não foi possível colapsar os dois laços em um só porque dentro do laço interno um mesmo elemento da matriz seria incrementado por mais de uma thread, causando possíveis colisões.

O terceiro ponto foi na cópia dos índices dos nós da matriz ordenada para um novo vetor. Sendo uma cópia simples, a paralelização foi feita da mesma maneira que no primeiro ponto, simplesmente dividindo as iterações do laço de forma indiscriminada entre o maior número de threads possível.

O quarto ponto foi o que fez maior diferença na performance, por paralelizar uma parte mais demorada do processo. O ponto em questão é o loop interno da função findClique, que encontra o clique local a partir da lista de nós ordenada pelo grau. O loop interno percorre todos os nós ainda na lista de candidatos da clique, verificando se este é adjacente a cada membro já pertencente à clique. No caso que o candidato é adjacente a todos, ele é incluso em uma nova lista. A ordem com a qual eles são inclusos nesta nova lista é importante, e deve ser igual a ordem das iterações do loop, por isso, neste caso, utilizou-se uma cláusula de loop for paralelizado ordenado do OpenMP, mantendo a ordem original das iterações. Manter a ordem original é importante para chegar ao mesmo resultado da versão sequencial.